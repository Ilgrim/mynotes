// Code generated by Icestudio 0.4.0-dev
// Tue, 21 May 2019 14:38:06 GMT

`default_nettype none

module main #(
 parameter v55b594 = 500,
 parameter vb8c6f6 = 500
) (
 input vf69047,
 input vc41f0b,
 input vclk,
 output vdd5bdb,
 output vb08599,
 output [0:5] vinit
);
 localparam p0 = v55b594;
 localparam p4 = vb8c6f6;
 wire w1;
 wire w2;
 wire w3;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 assign vdd5bdb = w1;
 assign w3 = vf69047;
 assign vb08599 = w5;
 assign w6 = vc41f0b;
 assign w8 = vclk;
 assign w9 = vclk;
 assign w10 = vclk;
 assign w11 = vclk;
 assign w9 = w8;
 assign w10 = w8;
 assign w10 = w9;
 assign w11 = w8;
 assign w11 = w9;
 assign w11 = w10;
 v554260 #(
  .v55b594(p0)
 ) vbc76ba (
  .v120553(w1),
  .vd8902b(w2),
  .v096121(w8)
 );
 v2107ac v70ee64 (
  .v64879c(w2),
  .vd9601b(w3),
  .vbbbce8(w9)
 );
 v554260 #(
  .v55b594(p4)
 ) v8590d0 (
  .v120553(w5),
  .vd8902b(w7),
  .v096121(w10)
 );
 v2107ac ve62eb6 (
  .vd9601b(w6),
  .v157a67(w7),
  .vbbbce8(w11)
 );
 assign vinit = 6'b000000;
endmodule

module v554260 #(
 parameter v55b594 = 300,
 parameter v83bbc4 = 255,
 parameter vf99d89 = 0,
 parameter vf092fa = -1,
 parameter v96657e = 0
) (
 input v096121,
 input vd8902b,
 output v120553
);
 localparam p0 = v55b594;
 localparam p1 = v83bbc4;
 localparam p2 = vf99d89;
 localparam p4 = vf092fa;
 localparam p6 = v83bbc4;
 localparam p10 = v96657e;
 wire [0:7] w3;
 wire [0:7] w5;
 wire [0:7] w7;
 wire [0:7] w8;
 wire [0:7] w9;
 wire [0:7] w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 assign w17 = v096121;
 assign v120553 = w18;
 assign w19 = vd8902b;
 assign w20 = vd8902b;
 assign w22 = v096121;
 assign w23 = v096121;
 assign w24 = vd8902b;
 assign w5 = w3;
 assign w11 = w3;
 assign w11 = w5;
 assign w20 = w19;
 assign w22 = w17;
 assign w23 = w17;
 assign w23 = w22;
 assign w24 = w19;
 assign w24 = w20;
 vf061f4 ve77f8f (
  .v165d22(w3),
  .vf04ee2(w18),
  .v3d0d46(w23)
 );
 v554260_vb85f7d #(
  .Tms(p0),
  .Max(p1),
  .Min(p2)
 ) vb85f7d (
  .o(w12),
  .clk(w17)
 );
 v89d234 vc09200 (
  .vb1c024(w3),
  .v39f831(w9),
  .vf892a0(w16),
  .v41eb95(w22)
 );
 v7d7474 #(
  .v8d305c(p4)
 ) v785073 (
  .ve41da3(w5),
  .v9c083a(w7)
 );
 v5ad97e #(
  .vc5c8ea(p6)
 ) v36cfa8 (
  .v26dbdb(w8)
 );
 v359a55 vd19da7 (
  .vd6b984(w7),
  .v02d898(w8),
  .vf24dba(w9),
  .v50d6c6(w24)
 );
 vca7316 #(
  .v6b316b(p10)
 ) v759d47 (
  .v40cb98(w11),
  .v18e78c(w25)
 );
 vb2090f va5e8d0 (
  .v0e28cb(w12),
  .v3ca442(w13),
  .vcbab45(w15)
 );
 v35f267 va69672 (
  .vcbab45(w14),
  .v0e28cb(w25)
 );
 v816138 vfa2ce5 (
  .vcbab45(w13),
  .v0e28cb(w14),
  .v3ca442(w19)
 );
 v816138 v2ff7f5 (
  .v0e28cb(w15),
  .vcbab45(w16),
  .v3ca442(w21)
 );
 v1b3913 vfe3b05 (
  .ve78ab8(w20),
  .v3487af(w21)
 );
endmodule

module v554260_vb85f7d #(
 parameter Tms = 0,
 parameter Max = 0,
 parameter Min = 0
) (
 input clk,
 output o
);
 //---- Corazon de tics de µs
 //-- La frecuencia se calcula dividiendo el tiempo total (Tms)
 //-- entre la diferencia de niveles. Nos indica el numero de 
 //-- tics que hay que dar para llegar de Min a Max en Tms tiempo
 
 localparam US = (Tms*1000)/(Max-Min+1);
 
 //-- Constante para dividir y obtener una frecuencia de 1MHz
 localparam M = 12*US;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = (divcounter == M-1);
 
 //-- La salida es la señal de overflow
 assign o = reset;
 
 
 
 
endmodule

module vf061f4 #(
 parameter vaffc96 = 7
) (
 input v3d0d46,
 input [7:0] v165d22,
 output vf04ee2
);
 localparam p3 = vaffc96;
 wire w0;
 wire [0:7] w1;
 wire w2;
 wire [0:7] w4;
 wire [0:7] w5;
 wire [0:7] w6;
 wire w7;
 wire w8;
 wire [0:7] w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 assign vf04ee2 = w7;
 assign w9 = v165d22;
 assign w10 = v3d0d46;
 assign w11 = v3d0d46;
 assign w12 = v3d0d46;
 assign w13 = v3d0d46;
 assign w14 = v3d0d46;
 assign w5 = w4;
 assign w11 = w10;
 assign w12 = w10;
 assign w12 = w11;
 assign w13 = w10;
 assign w13 = w11;
 assign w13 = w12;
 assign w14 = w10;
 assign w14 = w11;
 assign w14 = w12;
 assign w14 = w13;
 v89d234 v219b82 (
  .vf892a0(w0),
  .v39f831(w1),
  .vb1c024(w6),
  .v41eb95(w12)
 );
 v7eacdf va8d776 (
  .v2dffca(w0),
  .v10eedb(w2),
  .v0884a0(w11)
 );
 vec5121 #(
  .vaf1d6e(p3)
 ) vab8a2b (
  .v7ff276(w2),
  .vdf5b7a(w4)
 );
 v27fd6d v7ab306 (
  .v9892c7(w5),
  .v9f69ad(w6),
  .v18e78c(w8)
 );
 v1c7dae vd8c9cc (
  .ve8318d(w7),
  .vf54559(w8),
  .va4102a(w13)
 );
 vd21196 v94e894 (
  .v7a3c8e(w4),
  .vfdbd5b(w10)
 );
 va940ef v65d4ca (
  .v5cd41a(w1),
  .v0ad762(w9),
  .v41eb95(w14)
 );
endmodule

module v89d234 #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input [7:0] v39f831,
 input vf892a0,
 output [7:0] vb1c024
);
 localparam p0 = v422d28;
 wire [0:7] w1;
 wire [0:7] w2;
 wire w3;
 wire w4;
 assign vb1c024 = w1;
 assign w2 = v39f831;
 assign w3 = vf892a0;
 assign w4 = v41eb95;
 v89d234_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .q(w1),
  .d(w2),
  .load(w3),
  .clk(w4)
 );
endmodule

module v89d234_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input [7:0] d,
 input load,
 output [7:0] q
);
 localparam N = 8;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
   if (load)
     q <= d;
endmodule

module v7eacdf (
 input v0884a0,
 input v10eedb,
 output v2dffca
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v10eedb;
 assign v2dffca = w1;
 assign w2 = v0884a0;
 v7eacdf_v115ffb v115ffb (
  .i(w0),
  .o(w1),
  .clk(w2)
 );
endmodule

module v7eacdf_v115ffb (
 input clk,
 input i,
 output o
);
 reg q = 0;
 
 always @(posedge clk)
   q <= i;
   
 assign o = (q & ~i);  
endmodule

module vec5121 #(
 parameter vaf1d6e = 0
) (
 input [7:0] vdf5b7a,
 output v7ff276
);
 localparam p0 = vaf1d6e;
 wire w1;
 wire [0:7] w2;
 assign v7ff276 = w1;
 assign w2 = vdf5b7a;
 vec5121_vd80544 #(
  .BIT(p0)
 ) vd80544 (
  .o(w1),
  .i(w2)
 );
endmodule

module vec5121_vd80544 #(
 parameter BIT = 0
) (
 input [7:0] i,
 output o
);
 assign o = i[BIT];
endmodule

module v27fd6d (
 input [7:0] v9892c7,
 input [7:0] v9f69ad,
 output v18e78c
);
 wire w0;
 wire [0:7] w1;
 wire [0:7] w2;
 assign v18e78c = w0;
 assign w1 = v9f69ad;
 assign w2 = v9892c7;
 v27fd6d_vd75681 vd75681 (
  .eq(w0),
  .b(w1),
  .a(w2)
 );
endmodule

module v27fd6d_vd75681 (
 input [7:0] a,
 input [7:0] b,
 output eq
);
 assign eq = (a < b);
endmodule

module v1c7dae #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 v1c7dae_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3)
 );
endmodule

module v1c7dae_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 reg q = INI;
 always @(posedge clk)
   q <= d;
endmodule

module vd21196 (
 input vfdbd5b,
 output [7:0] v7a3c8e
);
 wire w0;
 wire [0:7] w1;
 assign w0 = vfdbd5b;
 assign v7a3c8e = w1;
 vd21196_vf093da vf093da (
  .clk(w0),
  .q(w1)
 );
endmodule

module vd21196_vf093da (
 input clk,
 output [7:0] q
);
 //-- Número de bits del contador
 localparam N = 8;
 
 reg [N-1:0] q = 0;
 
 always @(posedge clk)
     q <= q + 1;
endmodule

module va940ef #(
 parameter v422d28 = 0
) (
 input v41eb95,
 input [7:0] v0ad762,
 output [7:0] v5cd41a
);
 localparam p0 = v422d28;
 wire w1;
 wire [0:7] w2;
 wire [0:7] w3;
 assign w1 = v41eb95;
 assign v5cd41a = w2;
 assign w3 = v0ad762;
 va940ef_v9148cb #(
  .INI(p0)
 ) v9148cb (
  .clk(w1),
  .q(w2),
  .d(w3)
 );
endmodule

module va940ef_v9148cb #(
 parameter INI = 0
) (
 input clk,
 input [7:0] d,
 output [7:0] q
);
 localparam N = 8;
 
 reg [N-1:0] q = INI;
 
 always @(posedge clk)
     q <= d;
endmodule

module v7d7474 #(
 parameter v8d305c = 1
) (
 input [7:0] ve41da3,
 output [7:0] v9c083a
);
 localparam p0 = v8d305c;
 wire [0:7] w1;
 wire [0:7] w2;
 assign w1 = ve41da3;
 assign v9c083a = w2;
 v7d7474_va0c26a #(
  .k(p0)
 ) va0c26a (
  .a(w1),
  .s(w2)
 );
endmodule

module v7d7474_va0c26a #(
 parameter k = 0
) (
 input [7:0] a,
 output [7:0] s
);
 assign s = a + k;
endmodule

module v5ad97e #(
 parameter vc5c8ea = 0
) (
 output [7:0] v26dbdb
);
 localparam p0 = vc5c8ea;
 wire [0:7] w1;
 assign v26dbdb = w1;
 v5ad97e_v465065 #(
  .VALUE(p0)
 ) v465065 (
  .k(w1)
 );
endmodule

module v5ad97e_v465065 #(
 parameter VALUE = 0
) (
 output [7:0] k
);
 assign k = VALUE;
endmodule

module v359a55 (
 input [7:0] v02d898,
 input [7:0] vd6b984,
 input v50d6c6,
 output [7:0] vf24dba
);
 wire w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:7] w3;
 assign w0 = v50d6c6;
 assign w1 = vd6b984;
 assign w2 = v02d898;
 assign vf24dba = w3;
 v359a55_ve4e0df ve4e0df (
  .sel(w0),
  .i0(w1),
  .i1(w2),
  .o(w3)
 );
endmodule

module v359a55_ve4e0df (
 input [7:0] i1,
 input [7:0] i0,
 input sel,
 output [7:0] o
);
 //-- Multiplexor de 2 a 1, 
 //-- de 8 bits
 
 reg [7:0] o;
 
 always @(*) begin
     case(sel)
         0: o = i0;
         1: o = i1;
         default: o = i0;
     endcase
 end
 
 
endmodule

module vca7316 #(
 parameter v6b316b = 0
) (
 input [7:0] v40cb98,
 output v18e78c
);
 localparam p1 = v6b316b;
 wire w0;
 wire [0:7] w2;
 assign v18e78c = w0;
 assign w2 = v40cb98;
 vca7316_vd75681 #(
  .K(p1)
 ) vd75681 (
  .eq(w0),
  .a(w2)
 );
endmodule

module vca7316_vd75681 #(
 parameter K = 0
) (
 input [7:0] a,
 output eq
);
 assign eq = (a == K);
endmodule

module vb2090f (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vb2090f_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

module vb2090f_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta AND
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a & b;
 
 //-- endmodule
endmodule

module v35f267 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v35f267_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

module v35f267_vd54ca1 (
 input a,
 output c
);
 //-- Puerta NOT
 
 //-- module (input wire a, output wire c);
 
 
 assign c = ~a;
 
 
 //-- endmodule
 
endmodule

module v816138 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v816138_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

module v816138_vf4938a (
 input a,
 input b,
 output c
);
 //-- Puerta OR
 
 //-- module and (input wire a, input wire b,
 //--             output wire c);
 
 assign c = a | b;
 
 //-- endmodule
endmodule

module v1b3913 (
 input ved8395,
 input ve78ab8,
 output v3487af
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 assign w0 = ve78ab8;
 assign w1 = ved8395;
 assign w4 = ve78ab8;
 assign v3487af = w5;
 assign w4 = w0;
 v1c7dae vbf8366 (
  .vf54559(w0),
  .va4102a(w1),
  .ve8318d(w2)
 );
 v35f267 v5053a8 (
  .v0e28cb(w2),
  .vcbab45(w3)
 );
 vb2090f v758f4d (
  .v0e28cb(w3),
  .v3ca442(w4),
  .vcbab45(w5)
 );
endmodule

module v2107ac (
 input vbbbce8,
 input vd9601b,
 output v157a67,
 output v64879c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = vd9601b;
 assign v64879c = w1;
 assign w2 = vbbbce8;
 assign v157a67 = w3;
 v2107ac_v297cb2 v297cb2 (
  .d(w0),
  .tic(w1),
  .clk(w2),
  .state(w3)
 );
endmodule

module v2107ac_v297cb2 (
 input clk,
 input d,
 output state,
 output tic
);
 // Sincronizacion. Evitar 
 // problema de la metaestabilidad
 
 reg d2;
 reg r_in;
 
 always @(posedge clk)
  d2 <= d;
  
 always @(posedge clk)
   r_in <= d2;
 
 
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ r_in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= r_in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 //-- Generar tic en flanco de subida del boton
 reg old;
 
 always @(posedge clk)
   old <= btn_out_r;
   
 assign tic = !old & btn_out_r;
 
 //-- El estado del pulsador se saca por state
 assign state = btn_out_r;
 
 
endmodule
